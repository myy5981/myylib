# 红黑树
总是有人说，红黑树很好理解，只需要满足四个条件：

0. 每个节点不是黑色就是红色
1. 根节点是黑色
2. 将NULL视作叶子节点且是黑色
3. 红色节点的孩子不能是黑色节点（也就是红色节点不能相连）
4. 从根节点到叶子节点的路径上，黑色节点个数（黑高）相同。

主要是条件34

但是即使知道了这些完全理解并实现一个红黑树仍然有一定难度，本笔记记载如何正确理解红黑树

## 为什么需要红黑树且为什么需要上述条件约束
为了防止普通的二叉搜索树退化为链表，需要保持一颗二叉搜索树“平衡”。AVL树通过严格保证左右子树的高度相差不超过1实现平衡，但其实现平衡需要的代价（旋转操作）复杂度较高。红黑树也是一颗自平衡的二叉搜索树，条件34保证了最长路径不超过最短路径的2倍（因为黑高相同，最短时一条路径全为黑色，最长时黑红相间），换言之只要保证了条件34，红黑树就平衡了。

红黑树首先是一颗二叉搜索树，其插入删除查找过程和二叉搜索树相同，区别在于插入/删除后如何继续通过旋转且重新着色使之还是一颗合法的红黑树。

## 插入
先像一颗普通的二叉搜索树一样插入新节点，新节点的颜色置为红，之所以不置为黑，是因为黑节点插入后会导致左右子树黑高发生变化，这时红黑树也就“退化”成AVL树了（因为要严格保证黑高相同），故而插入红节点，插入红节点不影响黑高，不破坏条件4，但可能破坏条件3。所以后续的旋转作色操作，是为了在修复条件3的同时不破坏条件4。

注：以下使用n表示新插入的节点，p表示父节点，g表示祖父节点，u表所叔节点，小写表示红色，大写表示黑色。

情况1：插入的节点是根节点，也就是这是和红黑树的第一个节点，直接将这个节点的颜色置为黑以满足条件1,即可返回

情况2：插入节点的父节点是黑色，此时既不违反条件4，也不违反条件3，还是一颗合法的红黑树，直接返回即可。当插入第二层的两个节点时，由于根节点是黑色，故适用此情况，这一句说明，在后续情况345时，插入的节点一定有一个祖父节点（因为至少在第三层），且祖父节点一定是黑色（因为在插入之前这时一个合法的红黑树，父节点是红祖父节点一定是黑），且有一个叔节点（注意条件2,NULL看作黑色的叔节点）。

排除了两种最简单的情况，在情况345中，可以确定的是：

插入的红节点n的父节点p也是红节点，祖父节点G是黑节点，叔节点可能为红或黑

情况3：叔节点为红

```
    G            g            G            g    
   / \          / \          / \          / \   
  p   u  -->   P   U   or   u   p   -->  U   P  
 /            /                  \            \ 
n            n                    n            n
```

对于这颗子树，可以看到其黑高为1，只要调整后黑高还为1，就不会破坏条件4。所以直接将父亲节点和叔节点置为黑色，祖父节点置为红色。但是此时祖父节点g由于置为了红色，将祖父节点g看作新插入的节点，可能会违反条件3，所以需要迭代向上调整（令n=n.p.p），如果g是根节点，直接置为黑色，一方面条件2要求根节点为黑色，另一方面由于根节点是路径的起点，改变根节点的颜色不会影响黑高

情况4：叔节点为黑色，且n是一个右节点，p是一个左节点 或 n是一个左节点，p是一个右节点（三角形）

```
    G                       G          G                        G   
   / \                     / \        / \                      / \  
  p   U  -left rotate->   n   U  or  U   p  -right rotate->   U   n 
   \                     /              /                          \
    n                   p              n                            p
```
此时将n的父节点p左旋 或 右旋，将n看为p，原来的p看为新插入的n，转化为情况5再处理

情况5：叔节点为黑色，且n是一个左节点，p是一个左节点 或 n是一个右节点，p是一个右节点（直线形）
```
    G                        P           G                       P   
   / \                      / \         / \                     / \  
  p   U  -right rotate->   n   g   or  U   p  -left rotate->   g   n 
 /         & recolor            \           \   & recolor     /      
n                                U           n               U        
```
此时对p进行右旋 或 左旋，使P成为新的G并置为黑色，g成为了P的子节点，为了保证条件4，将g值为红色。

这种情况比较拗口，可以直接看图，可以发现此时不仅保证了条件3还保证了条件4，另外调整后的祖父节点（原来的p）是黑色，因此不会像情况3一样继续导致上方的错误需要迭代调整，也就是说，调整可以到此为止了。

在情况345中，每个情况右分为了两种，区分or的关键是p节点是左子节点还是右子节点，对于两种情况只需要交换操作中的left和right即可。

综合起来，调整的过程为：情况1经过迭代，要么直接合法，要么变为情况2，要么变为情况3。情况2调整一次变为情况3，情况3调整一次合法。

## 删除
红黑树删除的情况，按颜色分有两种：删除黑节点，删除红节点。按子结点情况分有三种：有一个子结点，有两个子结点，没有子结点。

所以可以穷举出6种：

一、删除有一个子节点的黑节点：该子结点一定是红节点，否则左右黑高不同。这种情况下，删除黑节点后，让红节点替代黑节点的位置，颜色改为黑节点。

二、删除有一个子节点的红节点：该子节点一定是黑节点，否则红红相邻，但此时左右黑高不同，矛盾。所以不可能存在这种情况，即红黑树中红节点不可能只有一个子结点（空节点不算）

三、删除没有子结点的红节点：红节点一定有一个父节点，这种情况下直接删除即可。

四、删除没有子结点的黑节点：这种情况最复杂，放到最后讨论。

五、删除有两个子结点的红/黑节点：此时找到该节点的后继节点（比他大的最小节点），也就是在它的右子树中不断向左遍历，找到一个最小的节点。替换后继节点和删除节点的位置（此时可能甚至不是一颗二叉排序树，但是没关系，因为不合法的节点马上要被删除）也替换颜色。易得后继节点的左子结点一定为NULL，所以交换后，一定会变为情况一、三、四的一种。代码实现时可以先写这种情况。

**最后再来讨论删除没有子结点的黑节点情况，这种情况本质上是一颗子树的黑高减1了**

P.S. 真的很复杂，写完了代码不想写文档了...太累了

## 性能
简单测试一下性能，插入1000w随机打乱的0-9999999，再随机删除，插入用时14.2s，删除用时5.8s，但是该时间不包括分配内存的开销。