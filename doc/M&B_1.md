# 大数模乘中的蒙哥马利算法与巴雷特算法——1
符号说明：

|符号|说明|
|:---:|:---|
|$X$|超过有限域需要取模的数，也用作被除数|
|$P$|有限域的阶，即模数，也用作除数|
|$i$|P的bit位数|
|$j$|X的bit位数|
|$k$|选取的辅助量的幂次|
|$d$|商|
|$r$|余数，即 $X = d\cdot P+r$|
|$q_1,q_2,q_3,r_1,r_2$|其他中间变量|

## 提出问题
在RSA中需要计算 $m^q \bmod N  $ ，在SM2中大量涉及到素数域GF(P)中的乘法运算即 $(a\times b)\bmod P$ ，而其中N，q通常有1024或2048位，P则是一个256的大整数，如何高效计算模乘成了实现这些算法的重要问题。由于正在着手实现SM2加密算法，本文将以SM2为例展开叙述。

在SM2中P固定为FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF这个256位的大整数（就是说可以以常量写在代码里），着意味着在后续算法中，凡是从P派生出的中间数，均可以提前计算（Matlab，Openssl，GMP...怎么算随你了）并写死在代码里面，在考量算法效率时，这一部分是不会计入的，哪怕非常低效。同理在RSA中，虽然N，q不固定，但是在生成密钥后亦可提前计算，不影响加解密时的效率。

在SM2中的运算是GF(P)下的，这里默认 $a,b\in GF(P)$（即 $0\le a<P,0\le b<P$ ）。a,b都是256位整数，若不考虑有限域，a*b是一个512位整数。

多一句嘴，这里P已经超过了有限域中最大值的一半，因此计算 $(a+b)\bmod P$ 时直接减就行了，至多减一次。当然如果用标题的方法也不拦着。

要计算模数，本质问题是计算除法（如果愿意循环减来赌商不大当我没说），而大数除法非常困难。

除非，除数是2的幂次，可以直接使用位移计算除法，使用截断计算模数。

上面一段仅仅涉及到小学知识，总结为两句话：

1. 预计算不算耗时
2. 除以 $2^k$ 计算机计算很快

## 巴雷特约减
Barrett Reduction是一种大数取模的方法。

本质就是利用预计算，将除以一个任意的数转化为除以2的幂次（取模和除法是统一的，算出了商自然很快的以得出模）：

$$\frac{X}{P} =\frac{\frac{X}{2^k} }{\frac{P}{2^k} } =\frac{X\cdot \frac{2^k}{P} }{2^k} $$

问题化为如何选取一个合适的k，但要考虑到，计算机计算除以$2^k$时，是要向下取整的，会丢失精度，也就是说这是一个估算的算法：

$$d=\left \lfloor \frac{X\cdot \left \lfloor \frac{2^k}{P}  \right \rfloor }{2^k}  \right \rfloor \approx \frac{X}{P}$$

如何使计算结果与真实结果相近，这对k的选取就提出了要求。

设P的位数为$i$，X的位数为$j$，既然要取模那么$j>i$，甚至$j>>i$，否则取模没有意义。

#### 首先第一个问题：

$\left \lfloor \frac{2^k}{P}  \right \rfloor$ 不应为0，否则算出来的结果就是0，丢失精度太多，则应有 $k\ge i$ ，$k$越大，精度越高。

#### 其次第二个问题：

$$\frac{2^k}{P}-1 < \left \lfloor \frac{2^k}{P}  \right \rfloor \le \frac{2^k}{P}$$
$$\frac{X\cdot 2^k}{P}-X < X\cdot \left \lfloor \frac{2^k}{P}  \right \rfloor \le \frac{X\cdot 2^k}{P}$$
$$\frac{X}{P}-\frac{X}{2^k} < \frac{X\cdot \left \lfloor \frac{2^k}{P}  \right \rfloor }{2^k}  \le \frac{X}{P}$$
$$\frac{X}{P}-\frac{X}{2^k}-1<\left \lfloor \frac{X\cdot \left \lfloor \frac{2^k}{P}  \right \rfloor }{2^k}  \right \rfloor \le \frac{X}{P}$$

我们希望不等式左边和右边的差距尽可能小，这样计算的结果就非常逼近真实结果，所以$k\ge j$（如果不满足此，那么在计算出商d然后计算$R=X-d\cdot P$后，由于误差较大需要再减几次P，而具体减多少次是不可预估的）

当然，$k$也不是越大越好，一方面 $\lim_{k \to \infty} \frac{X}{2^k} = 0$ 过大的$k$对区间范围（这里的范围指的是区间中的整数）没有影响（举例就是区间 $(\frac{1}{2^{10}},2)$ 和区间 $(\frac{1}{2^{1000}},2)$ 中的整数个数相同的，很简单的道理）。另一方面，$k$越大导致乘法计算越耗时。所以一般就取 $k=j$ 。

#### 再次第三个问题：

在上述算法的应用中，需要计算$\frac{2^k}{P}$，这仍然是非常耗时的，因为大多数时候P是固定的，我们的解决办法是，最好能预先计算出$\frac{2^k}{P}$备用，这就要求$k$最好也是固定的，至少$k$只与$i$有关。如果如上述所说取$k=j$，那么每输入一个X都要计算$\frac{2^k}{P}$，算法就失去了意义。

为了解决这个问题，只能舍弃一些算法的灵活度，预先规定好$X$的范围。

首先算法规定$k=2i$，即模数位长的两倍（有些文章喜欢写：$k=2\left \lceil log_{2}P  \right \rceil $），其次规定$j\le 2i$，即X位数不超过P位数的2倍。如此规定，可能是因为这种情况最为常见，现在密码学中常用的是某一有限域中的模乘运算，两个256位数字相乘得到512位，然后再对一个256位数字取模，如此规定刚好适应了这种最常见的情况。如果确实有特殊，从原理上说可以打破此规定，针对可能出现的X的范围预先取一个合适的k即可。

关于巴雷特约减的铺垫到此结束，下一章节叙述算法详情
