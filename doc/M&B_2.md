# 大数模乘中的蒙哥马利算法与巴雷特算法——2
符号说明：

|符号|说明|
|:---:|:---|
|$X$|整数，超过有限域需要取模的数，也用作被除数|
|$P$|整数，有限域的阶，即模数，也用作除数|
|$i$|整数，P的bit位数|
|$j$|整数，X的bit位数|
|$2k$|整数，选取的辅助量的幂次|
|$d$|整数，商|
|$r$|整数，余数，即 $X = d\cdot P+r$|
|$q_1,q_2,q_3,r_1,r_2$|整数，其他中间变量|

## Barrett Reduction
### 算法描述：
用于计算 $X\bmod P$ ，其中X的bit位不超过P的bit位的两倍。

### 算法流程（下面的除法均是计算机中的整除）：
#### 预计算：
1. 记 $i=\left \lceil log_{2}P  \right \rceil $ ，取 $2k=2i$ ，即k是P位数的两倍
2. 计算 $m=\frac{2^{2k}}{P}$ 

#### 正式计算第一部分——求商：
1. 输入X
2. 计算 $q_1=\frac{X}{2^{k-1}}$
3. 计算 $q_2=q_1\cdot m$
4. 计算 $q_3=\frac{q_2}{2^{k+1}}$

#### 正式计算第二部分——取模：
1. 计算 $r_1=X \bmod 2^{k+1}$（即保留后i+1位）
2. 计算 $r_2=(q_3 \cdot P)\bmod 2^{k+1}$
3. 计算 $r=r_1-r_2$
4. 如果 $r>P$，则计算 $r=r-P$（纠正整除带来的误差，下文会证明最多减一次）
5. $r$即为最终结果

### 解释
可以看到该算法与上一章所述的基本原理有一些出入，主要是在乘以$m$之前，先对$X$作了一部分除法，乘完之后再除剩下的部分。这样的好处是可以减少乘法运算的开销，至于这样作会不会对结果以及精度造成影响，且看下文分解：

首先，这很好理解：
$$r=X\bmod P；X=d\cdot P+r；\left \lfloor \frac{X}{P} \right \rfloor =d$$

then：
$$m=\left \lfloor \frac{2^{2k}}{P} \right \rfloor 即\frac{2^{2k}}{P}-1<m\le \frac{2^{2k}}{P}$$
$$q_1=\left \lfloor \frac{X}{2^a} \right \rfloor 即\frac{X}{2^a}-1<m\le \frac{X}{2^a}$$
(这里用a取代原文中的k-1，稍后研究a的变化对乘法开销与约减精度的影响)

$$\frac{X\cdot 2^{2k-a}}{P}-\frac{2^{2k}}{P}-\frac{X}{2^a}+1<q_2=q_1\cdot m\le \frac{X\cdot 2^{2k-a}}{P}$$

then：
$$\left \lfloor \frac{X}{P}-\frac{2^a}{P}-\frac{X}{2^{2k}}+\frac{1}{2^{2k-a}} \right \rfloor <q_3=\left \lfloor \frac{q_2}{2^{2k-a}} \right \rfloor \le \left \lfloor \frac{X}{P} \right \rfloor =d$$

根据算法的前提条件：$\frac{X}{2^{2k}}<1；\frac{1}{2^{2k-a}}<1$。

如果如算法原文所说，取$a=k-1$，则$\frac{2^a}{P}<1$

那么：
$$d-2=\left \lfloor \frac{X}{P}-2 \right \rfloor<\left \lfloor \frac{X}{P}-\frac{2^a}{P}-\frac{X}{2^{2k}}+\frac{1}{2^{2k-a}} \right \rfloor$$
综上：
$$d-2<q_3\le d$$
$q_3$就是我们要求的近似商，之后计算 $r=X-q_3\cdot P$ 即得余数，由于是近似商，所以还需要判断一下r是否大于P，大于则再减一次即可，而由于 $q_3>d-2$ 所以至多再减一次。在这一过程中，整除法和取幂次模由于使用位运算忽略不计，我们仅仅计算了一次k-1位的乘法（求$q_2$）、一次2k位乘法（求$q_3\cdot P$）、一次的减法（求近似余数）以及至多一次的减法用于矫正。

那么a可否取区间$[0,2k]$内的其他值？之所以会有这个想法，主要是在于我不太能接受算法中先除以 $2^{k-1}$ 再除以 $2^{k+1}$ ，因为我已经实现了256bit乘256bit的乘法，懒得再写一遍257bit乘257bit的乘法，就思考了一下能不能先除以 $2^k$ 再除以 $2^k$。

回看该不等式：

$$\left \lfloor \frac{X}{P}-\frac{2^a}{P}-\frac{X}{2^{2k}}+\frac{1}{2^{2k-a}} \right \rfloor <q_3$$

若取a=0，其实就相当于第一章所说的原始算法，这样精度很高，但没有意义，原因还是这个：$\frac{1}{2^{10}}$ 与 $\frac{1}{2^{10000}}$ 在数值上差别不大。反而如此一来需要计算512*512位的乘法

若取a=2k，那意味着再算$q_1$时就成了0，这样近似商与实际之间相差太大，算法就退化成了循环减求余。

“这告诉我们凡事需要把握事物的度，不能过于激进或过于保守，偏向一侧会导致错误”（哲学乱入）

所以算法选择了a=k-1，实际上：a越大，则后续矫正减法的次数越多，a越小，除了让没有意义的精度（因为由于整除本来这部分精度就要被丢弃）越大外，只会增加乘法带来的开销。

但是我仍然不满足，在SM2的实际应用中，试问a可否取k？这样就可以复用256位乘法运算的函数。

当a=k时：

$$q_3>\left \lfloor \frac{X}{P}-\frac{2^k}{P}-\frac{X}{2^{2k}}+\frac{1}{2^k} \right \rfloor $$

实际上，由于$2^k>P$，此时不能保证

$$q_3>\left \lfloor \frac{X}{P}-\frac{2^k}{P}-\frac{X}{2^{2k}}+\frac{1}{2^k} \right \rfloor >\left \lfloor \frac{X}{P}-2 \right \rfloor$$

但是在SM2中P的值已知，带入计算我们可以保证：
$$q_3>\left \lfloor \frac{X}{P}-\frac{2^k}{P}-\frac{X}{2^{2k}}+\frac{1}{2^k} \right \rfloor >\left \lfloor \frac{X}{P}-3 \right \rfloor$$

这意味着至多一次的矫正减法变为至多两次的矫正减法，我认为是可以接受的。（在实际应用中，X是两个GF(P)中的元素相乘的结果，此时进一步带入，其实仍然最多一次，只是进行这一次矫正的概率增大了，而对于原算法，由于X是两个不大于P的数的乘积，实际上近似商与商之间没有误差，无需作减法矫正）

============================分割线============================

最后还有一点小问题，在正式计算第二部分中，先截断，再相减，再矫正这其实相当于小学在计算999982-999946时只计算82-64即可，会丢弃前面相同的9999，这样可以少算一半的减法，意义不大但有胜于无。

下一章浅谈蒙哥马利模乘
